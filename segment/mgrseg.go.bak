package segment

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
	"net"
	"net/netip"
	"unsafe"
)

/*
	MgrSeg 总是由client发出req, proxy server 回复resp

	todo: 这个不对，MgrSeg 还是有tcp头
*/

// MgrSegType PayloadLen Payload
// [0]        [1,3)      [3,n)
type MgrSeg []byte

const (
	typeOffset    = 0
	lenOffset1    = 1
	lenOffset2    = 3
	payloadOffset = 3

	mgrSegMiniSize = lenOffset2
)

func (ms MgrSeg) setType(typ MgrSegType) bool {
	if typ.Validate() {
		Segment(ms).SetID(MgrSegID)
		ms[typ] = byte(typ)
		return true
	}
	return false
}

func (ms MgrSeg) Type() MgrSegType {
	if Segment(ms).ID() == MgrSegID {
		return MgrSegType(ms[typeOffset])
	}
	return 0
}

func (ms MgrSeg) payloadLen() uint16 {
	return binary.BigEndian.Uint16(ms[lenOffset1:lenOffset2])
}

func (ms MgrSeg) setPayloadLen(n uint16) {
	binary.BigEndian.PutUint16(ms[lenOffset1:lenOffset2], n)
}

func (ms MgrSeg) payload() []byte {
	return ms[payloadOffset : payloadOffset+ms.payloadLen()]
}

//go:generate stringer -output=mgrset_gen.go -trimprefix=MgrSeg -type=MgrSegType
type MgrSegType uint8

const (
	enum_start MgrSegType = iota

	MgrSegCrypto    // 是否加密
	MgrSegIPv6      // 是否支持IPv6
	MgrSegEndConfig // 结束mgr初始化配置
	MgrSegAddTCP    // 新增tcp代理
	MgrSegDelTCP    // 删除tcp代理
	MgrSegAddUDP    // 新增udp代理
	MgrSegDelUDP    // 删除udp代理
	MgrSegPackLoss  // 请求Server报告上行丢包率
	MgrSegPing      // ping请求

	enum_end
)

func (st MgrSegType) Validate() bool {
	return enum_start < st &&
		st < enum_end
}

func (st MgrSegType) IsConfig() bool {
	return st.Validate() && st <= MgrSegEndConfig
}

func ReadMgrMsg(conn net.Conn) (MgrSeg, error) {
	var b = make(MgrSeg, mgrSegMiniSize)

	if _, err := io.ReadFull(conn, b); err != nil {
		return nil, err
	}

	n := int(b.payloadLen())
	for len(b) < n+mgrSegMiniSize {
		b = append(b, 0)
		b = b[:cap(b)]
	}
	b = b[:n+mgrSegMiniSize]

	if _, err := io.ReadFull(conn, b[mgrSegMiniSize:]); err != nil {
		return nil, err
	}

	// return &MgrMsg{
	// 	Type:    b.Type(),
	// 	Payload: b[mgrSegMiniSize:],
	// }, nil
	return b, nil
}

type ErrIncorrectMgrMsgFormat MgrSeg

func (e ErrIncorrectMgrMsgFormat) Error() string {
	return fmt.Sprintf(
		"incorrect manager segment format: Type=%s Payload=%s",
		MgrSeg(e).Type(), hex.EncodeToString(MgrSeg(e).payload()),
	)
}

type MgrClient struct {
	conn net.Conn
}

// 1. 序列化req
// 2. 发送
// 3. 接收
// 4. 反序列化后返回
func NewMgrClient(conn net.Conn) *MgrClient {
	return &MgrClient{conn: conn}
}

func (mc *MgrClient) Crypto(crypto bool) (err error) {
	var req = makeMgrseg(MgrSegCrypto, 1)
	if crypto {
		req[len(req)-1] = 1
	}

	if _, err := mc.conn.Write(req); err != nil {
		return err
	}

	resp, err := ReadMgrMsg(mc.conn)
	if err != nil {
		return err
	}

	if err := assert(resp, MgrSegCrypto); err != nil {
		return err
	}
	if resp.payloadLen() != 0 {
		return ErrIncorrectMgrMsgFormat(resp)
	}

	return
}

func (mc *MgrClient) IPv6() (ipv6 bool, err error) {
	var req = makeMgrseg(MgrSegIPv6, 0)

	if _, err := mc.conn.Write(req); err != nil {
		return false, err
	}

	resp, err := ReadMgrMsg(mc.conn)
	if err != nil {
		return false, err
	}

	if err := assert(resp, MgrSegCrypto); err != nil {
		return false, err
	}
	if resp.payloadLen() != 1 {
		return false, ErrIncorrectMgrMsgFormat(resp)
	}

	if resp[mgrSegMiniSize] > 0 {
		return true, nil
	}
	return false, nil
}

// todo: 尝试grpc

type MgrServer struct {
	conn net.Conn
	rep  MgrSeg
}

func NewMgrServer(conn net.Conn) *MgrServer {
	return &MgrServer{
		conn: conn,
	}
}

func (ms *MgrServer) NextType() (MgrSegType, error) {
	var err error
	ms.rep, err = ReadMgrMsg(ms.conn)
	if err != nil {
		return 0, err
	}
	return ms.rep.Type(), nil
}

// 1. 反序列化
// 2. 获取参数并调用call
// 3. 根据call发返回值序列化resp
// 4. 回复
func (ms *MgrServer) Crypto(call func(crypto bool)) error {
	if err := assert(ms.rep, MgrSegCrypto); err != nil {
		return err
	} else if ms.rep.payloadLen() != 1 {
		return ErrIncorrectMgrMsgFormat(ms.rep)
	}
	var crypto bool
	if ms.rep[mgrSegMiniSize] > 0 {
		crypto = true
	}

	call(crypto)

	var resp = makeMgrseg(MgrSegCrypto, 0)
	if _, err := ms.conn.Write(resp); err != nil {
		return err
	}
	return nil
}

func (ms *MgrServer) IPv6(call func() bool) error {
	if err := assert(ms.rep, MgrSegIPv6); err != nil {
		return err
	} else if ms.rep.payloadLen() != 0 {
		return ErrIncorrectMgrMsgFormat(ms.rep)
	}

	ipv6 := call()

	var resp = makeMgrseg(MgrSegIPv6, 1)
	if ipv6 {
		resp[mgrSegMiniSize] = 1
	}
	if _, err := ms.conn.Write(resp); err != nil {
		return err
	}
	return nil
}

// server 接收到后解析成
type MgrSegCryptoReq struct {
}

// 用于client发出请求
func (m *MgrSegCryptoReq) Segment() MgrSeg {
	return nil
}

// client 接收到后解析成
type MgrSegCryptoResp struct {
}

// 用于server reply
func (m *MgrSegCryptoResp) Segment() MgrSeg {
	return nil
}

func (ms MgrSeg) Crypto() (bool, error) {
	assert(ms, MgrSegCrypto)
	if ms.payloadLen() == 1 {
		return ms.payload()[0] > 0, nil
	}
	return false, ErrIncorrectMgrMsgFormat(ms)
}
func MgrCrypto(crypto bool) MgrSeg {
	var seg = make(MgrSeg, mgrSegMiniSize+1)
	if crypto {
		seg[mgrSegMiniSize] = 1
	}
	setType(seg, MgrSegCrypto)
	return seg
}

func (ms MgrSeg) IPv6() (bool, error) {
	assert(ms, MgrSegIPv6)
	if ms.payloadLen() == 1 {
		return ms.payload()[0] > 0, nil
	}
	return false, ErrIncorrectMgrMsgFormat(ms)
}
func MgrIPv6(ipv6 bool) MgrSeg {
	var seg = make(MgrSeg, mgrSegMiniSize+1)
	if ipv6 {
		seg[mgrSegMiniSize] = 1
	}
	setType(seg, MgrSegCrypto)
	return seg
}

func (ms MgrSeg) EndConfig() error {
	assert(ms, MgrSegEndConfig)
	if ms.payloadLen() == 0 {
		return nil
	}
	return ErrIncorrectMgrMsgFormat(ms)
}
func MgrEndConfig() MgrSeg {
	return setType(make(MgrSeg, mgrSegMiniSize), MgrSegEndConfig)
}

func (ms MgrSeg) AddTCP() (netip.AddrPort, error) {
	return ms.addrport(MgrSegAddTCP)
}
func MgrAddTCP(id uint16) MgrSeg {

	// todo: req、resp不一样

	var seg = make(MgrSeg, mgrSegMiniSize+2)
	binary.BigEndian.PutUint16(seg[mgrSegMiniSize:], id)
	return setType(seg, MgrSegAddTCP)
}

func (ms MgrSeg) DelTCP() (netip.AddrPort, error) {
	return ms.addrport(MgrSegDelTCP)
}
func MgrDelTCP(addr netip.AddrPort) MgrSeg {
	return setType(addrport(addr), MgrSegDelTCP)
}

func (ms MgrSeg) AddUDP() (netip.AddrPort, error) {
	return ms.addrport(MgrSegAddUDP)
}
func MgrAddUDP(addr netip.AddrPort) MgrSeg {
	return setType(addrport(addr), MgrSegAddUDP)
}

func (ms MgrSeg) DelUDP(addr netip.AddrPort) (netip.AddrPort, error) {
	return ms.addrport(MgrSegDelUDP)
}
func MgrDelUDP(addr netip.AddrPort) MgrSeg {
	return setType(addrport(addr), MgrSegDelUDP)
}

func (ms MgrSeg) PackLoss() error {
	assert(ms, MgrSegPackLoss)
	if ms.payloadLen() == 0 {
		return nil
	}
	return ErrIncorrectMgrMsgFormat(ms)
}
func MgrPackLoss(pl float32) MgrSeg {
	var seg = make(MgrSeg, mgrSegMiniSize+4)
	binary.BigEndian.AppendUint32(seg[mgrSegMiniSize:mgrSegMiniSize+4], *(*uint32)(unsafe.Pointer(&pl)))
	return setType(seg, MgrSegPackLoss)
}

func (ms MgrSeg) addrport(t MgrSegType) (netip.AddrPort, error) {
	assert(ms, t)
	if ms.payloadLen() > 0 {
		return netip.ParseAddrPort(string(ms.payload()))
	}
	return netip.AddrPort{}, ErrIncorrectMgrMsgFormat(ms)
}
func addrport(addr netip.AddrPort) MgrSeg {
	p := addr.String()

	var seg = make(MgrSeg, mgrSegMiniSize+len(p))
	copy(seg[mgrSegMiniSize:], p)
	return seg
}

func setType(b MgrSeg, t MgrSegType) MgrSeg {
	if !b.setType(t) {
		panic(fmt.Sprintf("invalid manager segment type %d", t))
	}
	b.setPayloadLen(uint16(len(b) - mgrSegMiniSize))
	return b
}

func assert(seg MgrSeg, typ MgrSegType) error {
	if !typ.Validate() {
		return fmt.Errorf("invalid manager segment type %d", typ)
	} else if seg.Type() != typ {
		return fmt.Errorf("expect %s manager segment type, get %s", typ, seg.Type())
	}
	return nil
}

func makeMgrseg(typ MgrSegType, payloadLen int) MgrSeg {
	var seg = make(MgrSeg, mgrSegMiniSize+payloadLen)

	if !seg.setType(typ) {
		panic(fmt.Sprintf("invalid manager segment type %d", typ))
	}
	seg.setPayloadLen(uint16(len(seg) - mgrSegMiniSize))
	return seg
}

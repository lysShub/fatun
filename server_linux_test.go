//go:build linux
// +build linux

package fatun

import (
	"testing"

	"github.com/stretchr/testify/require"
	"golang.org/x/net/bpf"
	"gvisor.dev/gvisor/pkg/tcpip/header"
)

func Test_bpfFilterProtoAndLocalPorts(t *testing.T) {

	var suits = []struct {
		Return    uint16
		SkipPorts []uint16
		IP        header.IPv4
	}{
		{
			Return: 0,
			IP: header.IPv4{ // tcp  dst port 80
				0x45, 0x0e, 0x00, 0x34, 0x85, 0x54, 0x00, 0x00,
				0x40, 0x06, 0x21, 0x92, 0x67, 0x5e, 0xb9, 0x3d,
				0x6e, 0xf2, 0x44, 0x42, 0xac, 0xe9, 0x00, 0x50,
				0x7d, 0xef, 0x74, 0xbd, 0x00, 0x00, 0x00, 0x00,
				0x80, 0x02, 0xfa, 0xf0, 0x00, 0x50, 0x00, 0x00,
				0x02, 0x04, 0x05, 0x9b, 0x01, 0x03, 0x03, 0x08,
				0x01, 0x01, 0x04, 0x02,
			},
		},
		{
			Return: 0xffff,
			IP: header.IPv4{ // tcp  dst port 19986
				0x45, 0x0e, 0x00, 0x34, 0x85, 0x54, 0x00, 0x00,
				0x40, 0x06, 0x21, 0x92, 0x67, 0x5e, 0xb9, 0x3d,
				0x6e, 0xf2, 0x44, 0x42, 0xac, 0xe9, 0x4e, 0x12,
				0x7d, 0xef, 0x74, 0xbd, 0x00, 0x00, 0x00, 0x00,
				0x80, 0x02, 0xfa, 0xf0, 0x00, 0x50, 0x00, 0x00,
				0x02, 0x04, 0x05, 0x9b, 0x01, 0x03, 0x03, 0x08,
				0x01, 0x01, 0x04, 0x02,
			},
		},
		{
			Return: 0,
			IP: header.IPv4{ // udp dst port 80
				0x45, 0x00, 0x00, 0x1c, 0xad, 0x55, 0x00, 0x00,
				0x80, 0x11, 0x91, 0xa0, 0xc0, 0xa8, 0x2b, 0x23,
				0x08, 0x08, 0x08, 0x08, 0xcf, 0xf5, 0x00, 0x50,
				0x00, 0x08, 0xe5, 0xfa,
			},
		},
		{
			Return:    0xffff,
			SkipPorts: []uint16{19986},
			IP: header.IPv4{ // udp dst port 19986
				0x45, 0x00, 0x00, 0x1c, 0xad, 0x55, 0x00, 0x00,
				0x80, 0x11, 0x91, 0xa0, 0xc0, 0xa8, 0x2b, 0x23,
				0x08, 0x08, 0x08, 0x08, 0xcf, 0xf5, 0x4e, 0x12,
				0x00, 0x08, 0xe5, 0xfa,
			},
		},
		{
			Return:    0,
			SkipPorts: []uint16{19986},
			IP: header.IPv4{ // tcp  dst port 19986
				0x45, 0x0e, 0x00, 0x34, 0x85, 0x54, 0x00, 0x00,
				0x40, 0x06, 0x21, 0x92, 0x67, 0x5e, 0xb9, 0x3d,
				0x6e, 0xf2, 0x44, 0x42, 0xac, 0xe9, 0x4e, 0x12,
				0x7d, 0xef, 0x74, 0xbd, 0x00, 0x00, 0x00, 0x00,
				0x80, 0x02, 0xfa, 0xf0, 0x00, 0x50, 0x00, 0x00,
				0x02, 0x04, 0x05, 0x9b, 0x01, 0x03, 0x03, 0x08,
				0x01, 0x01, 0x04, 0x02,
			},
		},
		{
			Return: 0,
			IP: header.IPv4{ // icmp
				0x45, 0xc0, 0x00, 0x38, 0x00, 0x46, 0x00, 0x00,
				0xfa, 0x01, 0x04, 0x4b, 0x8b, 0xcb, 0x43, 0xdd,
				0xc0, 0xa8, 0x2b, 0x23, 0x0b, 0x00, 0xec, 0x69,
				0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x37,
				0x69, 0x5c, 0x00, 0x00, 0x01, 0x11, 0x4d, 0x41,
				0xc0, 0xa8, 0x2b, 0x23, 0x0e, 0x16, 0x09, 0x38,
				0x07, 0x47, 0x1f, 0x4a, 0x00, 0x23, 0xe1, 0xe1,
			},
		},
	}

	for _, e := range suits {
		vm, err := bpf.NewVM(bpfFilterProtoAndLocalTCPPorts(e.SkipPorts...))
		require.NoError(t, err)

		n, err := vm.Run(e.IP)
		require.NoError(t, err)
		require.Equal(t, e.Return, uint16(n))
	}
}
